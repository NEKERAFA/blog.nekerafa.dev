<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:slash="http://purl.org/rss/1.0/modules/slash/" version="2.0">
  <channel>
    <link>https://blog.nekerafa.dev/</link>
    <atom:link href="https://blog.nekerafa.dev/feed.xml" rel="self" type="application/rss+xml"/>
    <lastBuildDate>Sat, 10 Feb 2024 14:08:14 GMT</lastBuildDate>
    <generator>Lume v2.0.3</generator>
    <item>
      <title>Lo que necesitas saber antes de usar Godot</title>
      <link>https://blog.nekerafa.dev/posts/lo-que-necesitas-saber-de-godot/</link>
      <guid isPermaLink="false">https://blog.nekerafa.dev/posts/lo-que-necesitas-saber-de-godot/</guid>
      <description>En esta entrada quería hablar de dos puntos clave a la hora de desarrollar en Godot, uno de los principales motores de código abierto: la programación orientación a objetos por clases, y la programación dirigida por eventos.</description>
      <content:encoded>
        <![CDATA[<p>Buenas gente, para 2024 me he propuesto subir al menos una entrada cada mes en mi blog, ya sea un tutorial o alguna opinión mía, a ver que os parece. Quería haber subido esta entrada antes, pero estuve de mudanza de proveedor de dominio, ya que Google Domains cerraba (si, hije, si, otro servicio más), y quería mirar algún otro proveedor más barato.</p>
        <p>En esta entrada hablaré de dos puntos clave a la hora de desarrollar en <a href="https://godotengine.org/" target="_blank" rel="noopener">Godot</a>, uno de los principales motores de código abierto en estos momentos, que cuenta con una base de desarrolladores y contribuidores cada vez más grande, además de una comunidad bastante activa que nada tiene que envidiar a otros motores privativos como Unity o Unreal. Es por eso que creo que, ya seas principiante o, por el contrario, tengas un cierto conocimiento y experiencia previa, es fundamental que conozcas dos conceptos principalmente: La programación orientada a objetos por clases y la programación dirigida por eventos. Es verdad que otros motores tienen estos conceptos, y tampoco es algo nuevo que haya inventado Godot, pero, lo que me parece especial en este caso es que son características que vienen intrínsecas en la arquitectura del propio motor.</p>
        <p>Con respecto a la programación orientada a objetos, no es un concepto sencillo a priori. En clases de programación te cuentan que un objeto se divide en un estado, que es lo que se almacena en memoria, y una serie de eventos o mensajes a los que podemos llamar para modificar su estado. Esta división existe porque el punto principal de la programación orientada a objeto es poder reutilizar el comportamiento de los elementos dentro del programa (por ejemplo cómo responder al hacer click en un botón, cómo reproducir una animación, la forma para detectar colisiones, …) de cosas que son concretas al elemento en si (el sprite que contiene la animación, el tamaño de la caja de colisiones o los colores de fondo del botón). Esta división es muy clara en los lenguajes de programación orientada a objetos por clases, como es el caso de GDScript, y es que la clase actúa como el contrato y especificación de los mensajes a los que podemos llamar (los métodos que hemos definido en la clase), y las instancias son punteros a espacios en la memoria del ordenador en donde se especifica el estado actual de un objeto dado (la forma del estado viene definido por los atributos y propiedades de la clase). Que conste que en los lenguajes de programación orientados a prototipos como pueden ser Lua o ECMAscript también existe esta diferencia, pero es más borrosa, pero no entraré en detalle en este momento porque quiero hablar del caso particular de Lua en otro momento.</p>
        <p class="responsive-content"><a href="https://blog.nekerafa.dev/posts/lo-que-necesitas-saber-de-godot/definicion_objeto.webp"><img src="https://blog.nekerafa.dev/posts/lo-que-necesitas-saber-de-godot/definicion_objeto.webp" alt="Relación de los elementos de un objeto"></a></p>
        <p class="content-footer">Relación de los elementos de un objeto.</p>
        <p>Entonces, por una parte definición de las clases y por otra las instancias, pero necesitamos poder relacionar estos conceptos para, en el caso que nos atañe, compartir información y relacionarla de alguna forma para poder construir un videojuego. Con respecto a relacionar la información tenemos una herramienta que nos da la propia programación orientada a objetos por clases, que es la herencia. Y es que dada una clase, podemos hacer que esta incluya el comportamiento de una clase superior (lo que llamamos clase padre o superclase), y a su vez, crear nuevas clases que deriven de esta (las clases hijas o subclases). Con esto, podemos definir un comportamiento compartido entre clases en una superclase sin tener que reimplementarlo (o hacer un copy-paste) de cada vez. Ahora, con respecto a compartir la información hay una herramienta que nos permite simplificar de cierta forma la herencia, y es lo que se llama composición. Aquí lo que hacemos es que la clase tenga referencias directas a instancias de otras clases, y cuando tenemos que hacer algo, delegamos en los distintos métodos de las instancias a las que referenciamos. Y ahora podríamos pensar: ¿Cuándo usar uno u otro? De aquí hay mucha literatura de cómo hacerlo, pero, poniendo el caso de Godot, pues la respuesta es que ambos sistemas. El motor usa una aproximación mixta en la que el comportamiento de los objetos recaen en los Nodos, que son instancias de la clase <a href="https://docs.godotengine.org/en/stable/classes/class_node.html" target="_blank" rel="noopener">Node</a> o de una de sus subclases: tenemos desde <a href="https://docs.godotengine.org/en/stable/classes/class_node2d.html" target="_blank" rel="noopener">Node2D</a>, <a href="https://docs.godotengine.org/en/stable/classes/class_label.html" target="_blank" rel="noopener">Label</a>, <a href="https://docs.godotengine.org/en/stable/classes/class_animationplayer.html" target="_blank" rel="noopener">AnimationPlayers</a>, ¡y hasta <a href="https://docs.godotengine.org/en/stable/classes/class_timer.html" target="_blank" rel="noopener">Timers</a>! En Godot, si necesitamos un elemento que haga las mismas funciones que un botón, podemos heredar de la clase <a href="https://docs.godotengine.org/en/stable/classes/class_button.html" target="_blank" rel="noopener">Button</a> (o incluso de <a href="https://docs.godotengine.org/en/stable/classes/class_basebutton.html" target="_blank" rel="noopener">BaseButton</a>, que es una clase abstracta pensada ya para eso). Pero claro, ahora necesitamos hacer que nuestros nodos se puedan comunicar entre ellos, por lo que aquí entra en juego la composición. Un ejemplo son las escenas, en la que un nodo puede tener hijos siguiendo una estructura de árbol. No se hereda, si no que añadimos referencias dentro de una lista de hijos, y en la que derivamos parte del comportamiento. Un ejemplo lo podemos ver en un personaje 2D: Empezaríamos con un <a href="https://docs.godotengine.org/en/stable/classes/class_characterbody2d.html" target="_blank" rel="noopener">CharacterBody2D</a> (si, Godot ya incorpora un player controller como nodo), y asignarle como hijos un <a href="https://docs.godotengine.org/en/stable/classes/class_collisionshape2d.html" target="_blank" rel="noopener">CollisionShape2D</a>, un <a href="https://docs.godotengine.org/en/stable/classes/class_sprite2d.html" target="_blank" rel="noopener">Sprite2D</a> (o incluso un <a href="https://docs.godotengine.org/en/stable/classes/class_animatedsprite2d.html" target="_blank" rel="noopener">AnimatedSprite2D</a> si queremos animaciones, sin necesidad del <a target="_blank" href="https://docs.godotengine.org/en/stable/classes/class_animationplayer.html" rel="noopener">AnimationPlayer</a>), y listo. Ahora viene la parte más importante con respecto a esta forma de trabajar, y es que si queremos modificar el CharacterBody2D para meterle más movimientos a nuestro personaje (por ejemplo correr o un movimiento de dash), solo tenemos que extender de este nodo en concreto (que lo podemos hacer añadiéndole un script al nodo desde el editor, que en esencia es una extensión de esta clase). Tenéis más información tenéis este <a href="https://www.youtube.com/watch?v=74y6zWZfQKk" target="_blank" rel="noopener"><i class="fa-brands fa-youtube"></i> vídeo</a>.</p>
        <iframe class="responsive-content" width="100%" height="270px" src="https://www.youtube-nocookie.com/embed/74y6zWZfQKk?si=xmBKXU1T-G9vy8YO" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
        <p>Pues haciendo un breve resumen, en Godot tenemos composición de nodos en las escenas, y herencia dentro de un nodo al añadirle un script, y con esto estaría todo… bueno, todo no, y es que queda un detalle a mayores. La programación orientada a objetos vino para arreglar muchos problemas de reutilización y división de código, pero, como en sus inicios era un concepto bastante abstracto, sin unas reglas definidas, hizo que muchos desarrolladores empezaran a hacer código insostenible (si, en vez de arreglar, empeoró las cosas). Todo esto viene a que mucha gente venía con el chip de la programación imperativa, donde cada instrucción se ejecuta línea a línea. Es verdad que muchos lenguajes imperativos incorporan formas de definir funciones, interfaces o incluso módulos, pero aún así poco se parece al alto desacoplamiento que hay en un código dividido en clases. Para ello, en 1994, un grupo de ingenieros de software, conocidos como “The Gang of Four”, publicaron un libro que recopila unas reglas y formas de diseño que permitieran a los desarrolladores hacer de forma sencilla un mejor código siguiendo sus recomendaciones. Este libro se llama “Patrones de diseño: elementos para un software object-oriented reusable”. Si, he dicho la frase secreta para entrar en un mundo oscuro de la programación, que son los patrones de diseño. Un ente que tanto a estudiantes de informática como a seniors con 30 años de experiencia en el sector se nos atraganta bastante.</p>
        <p class="responsive-content"><a href="https://blog.nekerafa.dev/posts/lo-que-necesitas-saber-de-godot/herencia-vs-composicion.webp"><img width="100%" src="https://blog.nekerafa.dev/posts/lo-que-necesitas-saber-de-godot/herencia-vs-composicion.webp" alt="Herencia vs. Composición"></a></p>
        <p class="content-footer">Herencia vs. Composición.</p>
        <p>No entraré en detalles, porque este no es un tutorial sobre patrones de diseño (si queréis ejemplos, tenéis el libro de <a href="https://gameprogrammingpatterns.com/" target="_blank" rel="noopener">Game Programming Patterns</a>, de Robert Nystrom), pero dos de los patrones que tenemos que tener claro en Godot es el patrón <a href="https://gameprogrammingpatterns.com/observer.html" target="_blank" rel="noopener">Observador</a> y el patrón <a href="https://refactoring.guru/design-patterns/chain-of-responsibility" target="_blank" rel="noopener">Cadena de responsabilidad</a>.El primer patrón se define con dos componentes: un sujeto o objeto observable (que contiene una lista de objetos a los que notificar de posibles cambios o eventos) y un observador (que puede recibir estas notificaciones o eventos). En el caso del segundo patrón tenemos lo contrario, un objeto que tiene que realizar un trabajo (emisor), y delega en otro componente llamado receptor o manejador, que a su vez puede delegar en un segundo componente hasta llegar a un componente que nos permite realizar el trabajo requerido. Teniendo esto claro podemos entrar en lo que se llama programación orientada a eventos, caracterizada por mecanismos en los que procesos envían y reciben eventos, los procesan y/o delegan en otros componentes para realizar acciones. Muchos lenguajes de programación lo implementan mediante los llamados events, delegates y demás, pero Godot tiene una solución muy elegante para implementar esto: las señales. Tenéis un <a href="https://www.youtube.com/watch?v=BXkJeEGZr4o" target="_blank" rel="noopener"><i class="fa-brands fa-youtube"></i> vídeo</a> en el que lo explica de forma sencilla, así que voy a centrarme en lo importante, y es que la idea principal de las señales es el poder desacoplar de forma sencilla el comportamiento de los nodos, delegando su trabajo en otros sin tener que conocerlos.</p>
        <iframe class="responsive-content" width="100%" height="270px" src="https://www.youtube-nocookie.com/embed/BXkJeEGZr4o?si=XUd7irztklN9N0_K" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
        <p>Para explicarlo sigamos con el ejemplo de la escena de personaje. Supongamos que queremos detectar cuando el personaje colisionó con un obstáculo que puede hacerle daño. Podemos empezar a definir dos señales en el Player: <code>damaged</code> que se usará para notificar al Player de que ha sufrido daños, y <code>life_changed</code>, que recibe por parámetro la vida actual para notificar a los nodos que lo necesiten de que la vida del jugador ha cambiado. Para centralizar la información en el objeto, el Player contendrá su vida actual. Con esto podemos conectar la señal de <code>damaged</code> a una función que tiene el Player que sea <code>on_damaged</code>, y en la que podemos hacer que se reste una vida y emita la señal de <code>life_changed</code>. Bien, ¿y cómo comprobamos que el jugador ha sufrido daños? Pues haciendo que sea el otro objecto. Si, por ejemplo, este hereda de un <a target="_blank" href="https://docs.godotengine.org/en/stable/classes/class_area2d.html" rel="noopener">Area2D</a> tenemos la señal de <code>body_entered</code>, que podemos conectar a una función que sea <code>on_body_entered</code> dentro del obstáculo. Comprobando que si el objeto que colisiona tiene el nombre de &quot;Player&quot;, podemos emitir su señal de <code>damaged</code>. Bien, ahora necesitamos que tanto nuestro HUD como nuestro GameManager reaccione al cambio de vida (ya sea para modificar el número de vidas en pantalla o comprobar si el jugador ha muerto para ir a la pantalla de fin de juego). En este paso podríamos referenciar a estos objetos con el jugador para leer su vida en todo momento, pero es que para eso tenemos la señal creada antes. Si conectamos a cada objeto a esta señal, podemos hacer eso sin tener que acoplarlos al objeto del jugador. Con todo esto podemos poner la pega de que tenemos un código con un flujo con más carga al estar saltando de un objeto al otro, ya que las señales no son gratis y generar un overhead al invocar todo, pero, dependiendo de cómo implementamos el código, podemos obtener una buena mejoras y es que en Godot podemos responder a todos los objetos de forma paralela. Además, con esto tenemos un código más desacoplado, en el que cada clase tiene definida su funcionalidad, y por ende, más mantenible. Por ejemplo, podemos añadir más objetos que hagan daño al jugador replicando el funcionamiento de la bala.</p>
        <pre><code class="language-gdscript">## player.gd
        extends CharacterBody2D
        
        signal damaged
        signal life_changed(lifes)
        
        var lifes = 0
        
        func on_damaged(): # conectado con damaged
        lifes -= 1
        life_changed.emit(lifes)
        
        ...
        </code></pre>
        <pre><code class="language-gdscript">## bullet.gd
        extends Area2D
        
        func on_body_entered(body): # conectado con body_entered
        if body.name == &quot;Player&quot;:
        body.damaged.emit()
        
        ...
        </code></pre>
        <p class="content-footer">Ejemplo de implementación de los scripts.</p>
        <p>Hay muchas cosas más de las que podría hablar en Godot, porque pese a su pequeño tamaño, en realidad es un motor con bastantes cosas y de la que no es fácil masterizar y aprenderlo en una sola entrada, pero pienso que para empezar los dos temas que he tratado (escenas y nodos, y señales) son la base que tenemos que tener claro desde la primera toma de contacto para poder dominar Godot. Con todo, el mejor consejo que os puedo decir es que revisad la documentación, que a cada día que pasa está mucho más completa, y sobre todo haced cosas y experimentad con el motor, porque con ensayo y error es como más se aprende. Dicho esto espero que os haya gustado este tipo de entradas, que tengo ya algunas ideas en mente.</p>
        <p>¡Nos vemos en la próxima, saludos 😽!</p>
        ]]>
      </content:encoded>
      <pubDate>Tue, 30 Jan 2024 21:52:22 GMT</pubDate>
      <atom:updated>2024-02-10T12:53:20.000Z</atom:updated>
    </item>
    <item>
      <title>Mi resumen de 2023</title>
      <link>https://blog.nekerafa.dev/posts/mi-resumen-2023/</link>
      <guid isPermaLink="false">https://blog.nekerafa.dev/posts/mi-resumen-2023/</guid>
      <description>Ya estamos enfilando a un nuevo año, y creo que no soy la única persona que se pone a pensar, con cierta mirada de nostalgia, todo lo que nos ha pasado en este último año. A priori puede pensar que solo ha sido otro año más y ya, pero fijo que si rascamos un poco, nos encontramos con muchas cosas buenas. Aunque sean pequeñitas. Es por eso que  quería aprovechar este mi espacio para hacer un resumen de todo en lo que estuve metido este año, que en mi caso no fue poco viéndolo en perspectiva.</description>
      <content:encoded>
        <![CDATA[<p>Ya estamos enfilando a un nuevo año, y creo que no soy la única persona que se pone a pensar, con cierta mirada de nostalgia, todo lo que nos ha pasado en este último año. A priori puede pensar que solo ha sido otro año más y ya, pero fijo que si rascamos un poco, nos encontramos con muchas cosas buenas. Aunque sean pequeñitas. Es por eso que  quería aprovechar este mi espacio para hacer un resumen de todo en lo que estuve metido este año, que en mi caso no fue poco viéndolo en perspectiva.</p>
        <h3>2023: Reencontrandome con Godot</h3>
        <p>Personalmente fue un año bastante completito porque me propuse intentar aprender bien Godot, y creo que lo he conseguido con creces.</p>
        <p>En febrero me presenté a mi primera Game Jam con este motor, la Nokia 3310 Jam de 2023. Bueno, en realidad no es una jam de Godot, pero quería probar, y el resultado fue muy interesante. Hice un juego que simula escribir en el teclado de un Nokia 3310, es decir si quieres escribir, por ejemplo la letra r, tienes que pulsar la tecla 7 tres veces (para que pase de p, q, r). Este juego usa solo los nodos de la interfaz de Godot porque creo que la lógica es más sencilla que poner a diseñar sprites en pantalla, aparte que la gestión de la interfaz en Godot es una maravilla. Me recuerda, salvando las distancias, a sistemas de creación de UI como Glade, Gambas, o Qt Creator. Además, probé a exportar el proyecto a HTML para embeberlo en itch.io y he de reconocer que es una gozada. Rápido tanto para exportar como ejecutándose en mi navegador. Si queréis echarle un ojo, el código está liberado en mi GitLab código en mi <a href="https://gitlab.com/NEKERAFA/nokia3310-jam-2023" target="_blank" rel="noopener"><i class="fa-brands fa-gitlab"></i> GitLab</a>.</p>
        <iframe class="itch-desktop" frameborder="0" src="https://itch.io/embed/1945858?bg_color=c7f0d8&amp;fg_color=43523d&amp;link_color=43523d&amp;border_color=99c2aa" width="552" height="167"><a href="https://nekerafa.itch.io/catch-the-letter">Catch The LETTER by Rafael Alcalde Azpiazu, ArtistSynth</a></iframe>
        <iframe class="itch-mobile" frameborder="0" src="https://itch.io/embed/1945858?bg_color=c7f0d8&amp;fg_color=43523d&amp;link_color=43523d&amp;border_color=99c2aa" width="208" height="167"><a href="https://nekerafa.itch.io/catch-the-letter">Catch The LETTER by Rafael Alcalde Azpiazu, ArtistSynth</a></iframe>
        <p>Continuando con los experimentos en Godot, también en febrero estuve experimentando con la idea de cargar scripts e incluso assemblies en .NET en caliente dentro de Godot. Todo con la idea de poder hacer un sistema para incluir addons a nuestro juegos y apps, un poco a como funciona el modding en Minecraft, Cities: Skyline y similares. La idea salió guay, y fue bastante interesante. También puedes obtener el código en mi <a href="https://github.com/NEKERAFA/GodotAddonLoader" target="_blank" rel="noopener"><i class="fa-brands fa-github"></i> GitHub</a>.</p>
        <p>Aquí ya vi que Godot era un motor que prometía, por lo que me puse a hacer un OBS Deck (a lo <a href="https://www.elgato.com/us/en/s/welcome-to-stream-deck" target="_blank" rel="noopener">Stream Deck</a> de ElGato) usando Godot. La idea era embeberlo en una Raspberry Pi, que tengo una con una pantalla táctil a lo tablet. Conseguí algo sencillo de usar (si no fuera porque hace falta un teclado externo, pero bueno) y que, de momento, tiene pocas funcionalidades pero promete. También con este proyecto se me vinieron varias ideas a la cabeza pero claro, poco a poco. Se puede consultar el código en mi <a href="https://github.com/NEKERAFA/OBS-Godot-Deck" target="_blank" rel="noopener"><i class="fa-brands fa-github"></i> GitHub</a>. Eso si, no está del todo terminado, por lo que cógelo con pinzas.</p>
        <p>Ya en verano, yo de mi optimista, en agosto me apunté a ir a la <a href="https://godotengine.org/events/#godotmeetup-2023" target="_blank" rel="noopener">Godot User Meet</a>, que este año se celebró en Valencia (España). Fue un acierto porque pude conocer a gente hermosísima (por ejemplo al señor <a href="https://twitter.com/panreyes" target="_blank" rel="noopener">@Panreyes</a> 😼) y los proyectos con los que estaban manos a la obra o que ya habían terminado. También aproveché a ver a unes amigues por primera vez en persona y bueno, no sé, fue un viaje de 10. Y a ver, sin irnos muy lejos, entre medias me enteré muy de refilón del fenómeno de <a href="https://rothiotome.itch.io/numerica" target="_blank" rel="noopener"><i class="fa-brands fa-itch-io"></i> Numerica</a> de <a href="https://twitter.com/RothioTome" target="_blank" rel="noopener">Rocío Tomé</a>, más que nada porque organizó una jam. Así que fui de cabeza de nuevo con mi nuevo motorcillo, que ya le estaba pillando el gusanito, y publiqué un juego. También para Twitch, donde el chat tenía que completar la Pokédex nacional. De este proyecto ya hablé en <a href="https://blog.nekerafa.dev/posts/mi-resumen-2023/2023-09-17_la-importancia-de-la-tecnologia.md">otra entrada</a> sobre algunos problemas que me encontré (más por mi inexperiencia, tengo que reconocerlo), y que resolví en actualizaciones posteriores, por si le queréis echar un ojo, además de que el código está liberado en mi <a href="https://github.com/NEKERAFA/pokedexica-twitch" target="_blank" rel="noopener"><i class="fa-brands fa-github"></i> GitHub</a>.</p>
        <iframe class="itch-desktop" frameborder="0" src="https://itch.io/embed/2219644" width="552" height="167"><a href="https://nekerafa.itch.io/pokedexica-twitch">Pokédexica by Rafael Alcalde Azpiazu</a></iframe>
        <iframe class="itch-mobile" frameborder="0" src="https://itch.io/embed/2219644?bg_color=ff3050&amp;link_color=ff3050" width="208" height="167"><a href="https://nekerafa.itch.io/pokedexica-twitch">Pokédexica by Rafael Alcalde Azpiazu</a></iframe>
        <p>Sin perder el ritmo, llegó septiembre otra game jam. Esta vez para la Indie Spain Jam 2023. En este caso, me metí un poco a trastear con físicas, sprites y movimientos de cámara. De nuevo hay ciertas cosas que mejorar y que se me quedaron en el tintero. Aún así, si queréis saber más, tengo <a href="https://blog.nekerafa.dev/posts/mi-resumen-2023/2023-10-14_indie-spain-jam-2023.md">una entrada</a> hablando del tema de las físicas, como el resto, tengo el código liberado en mi <a href="https://gitlab.com/NEKERAFA/indie-spain-jam-23" target="_blank" rel="noopener"><i class="fa-brands fa-gitlab"></i> GitLab</a>.</p>
        <iframe class="itch-desktop" frameborder="0" src="https://itch.io/embed/2280591" width="552" height="167"><a href="https://nekerafa.itch.io/luna-lunatica">Luna Lunática by Rafael Alcalde Azpiazu</a></iframe>
        <iframe class="itch-mobile" frameborder="0" src="https://itch.io/embed/2280591" width="208" height="167"><a href="https://nekerafa.itch.io/luna-lunatica">Luna Lunática by Rafael Alcalde Azpiazu</a></iframe>
        <p>Ya llegando al final del año, a mediados de noviembre me presenté dentro de un grupo a la Mermelada Jam, una Game Jam organizada por la gente de la Spain Game Devs y Endorth. Esta vez, al disponer de poco tiempo, quise ir con más gente, y creo que el resultado fue, al menos para mí, muy gratificante. Es verdad que por problemas de tiempo, al ser al final la única persona que programaba, tuve que quitar horas de sueño, además de que hay ciertos puntos del mapa a arreglar, pero aún así es una experiencia que repetiría.</p>
        <iframe class="itch-desktop" frameborder="0" src="https://itch.io/embed/2374399?bg_color=fff&amp;fg_color=111&amp;link_color=d463ec&amp;border_color=bebebe" width="552" height="167"><a href="https://gerix-95.itch.io/find-your-self">Find yourself by Gerix_95, REIMYMONFER, Rafael Alcalde Azpiazu, ArtistSynth</a></iframe>
        <iframe class="itch-mobile" frameborder="0" src="https://itch.io/embed/2374399?bg_color=fff&amp;fg_color=111&amp;link_color=d463ec&amp;border_color=bebebe" width="208" height="167"><a href="https://gerix-95.itch.io/find-your-self">Find yourself by Gerix_95, REIMYMONFER, Rafael Alcalde Azpiazu, ArtistSynth</a></iframe>
        <p>Ya para finalizar, estuve estos días intentando resolver los problemas propuestos del <a href="https://adventofcode.com/" target="_blank" rel="noopener">Advent Of Code</a> de este año en Godot, para intentar practicar un poco. No se si soy el único pero estoy viendo que este año el nivel de dificultad está bastante alto, y para terminar creo que se necesita conocimiento muy amplios de matemáticas, optimizaciones y demás. Voy a intentar llegar hasta donde pueda, pero está chunguillo este año 😿. Tenéis lo que he hecho hasta ahora en mi <a href="https://gitlab.com/NEKERAFA/advent-of-code-2023" target="_blank" rel="noopener"><i class="fa-brands fa-gitlab"></i> GitLab</a>.</p>
        <iframe class="itch-desktop" frameborder="0" src="https://itch.io/embed/2404485" width="552" height="167"><a href="https://nekerafa.itch.io/advent-of-code-2023">Advent of Code 2023 by Rafael Alcalde Azpiazu</a></iframe>
        <iframe class="itch-mobile" frameborder="0" src="https://itch.io/embed/2404485" width="208" height="167"><a href="https://nekerafa.itch.io/advent-of-code-2023">Advent of Code 2023 by Rafael Alcalde Azpiazu</a></iframe>
        <p>Con todo, espero que tengáis un fin de año maravilloso, que estéis rodeades de las personas a las que más queréis, y a ver que nos depara el año que viene. Yo ya tengo varios proyectos en mente, a ver si en 2024 saco alguna cosilla más, entre ellas subir contenido de Godot en este blog jejeje.</p>
        <p>Así que un saludo y nos vemos 😸.</p>
        ]]>
      </content:encoded>
      <pubDate>Fri, 08 Dec 2023 21:46:10 GMT</pubDate>
      <atom:updated>2023-12-09T08:35:51.000Z</atom:updated>
    </item>
    <item>
      <title>Mi aporte a la Indie Spain Jam 2023</title>
      <link>https://blog.nekerafa.dev/posts/indie-spain-jam-2023/</link>
      <guid isPermaLink="false">https://blog.nekerafa.dev/posts/indie-spain-jam-2023/</guid>
      <description>Se que iba a hablar antes de otros proyectos, pero el mes pasado estuve inmerso en la Indie Spain Jam 2023, por lo que quería hablar esta vez de mi última experiencia, además de lo que aprendí en este evento, sobre todo porque, aunque no quedó entre los 25 primeros, pude terminar otro proyecto del que se me ocurren muchas cosas para hacer.</description>
      <content:encoded>
        <![CDATA[<p>Se que iba a hablar antes de otros proyectos, pero el mes pasado estuve inmerso en la Indie Spain Jam 2023, por lo que quería hablar esta vez de mi última experiencia, además de lo que aprendí en este evento, sobre todo porque, aunque no quedó entre los 25 primeros, pude terminar otro proyecto del que se me ocurren muchas cosas para hacer.</p>
        <p>Para la gente que no lo sepa, una Game Jam es un evento en el que desarrolladores, diseñadores y demás personas del mundo de los videojuegos se reúnen para, en un tiempo determinado, sacar un videojuego, ya sea de forma individual o por equipos. La idea es usar estos eventos para improvisar, aprender y sobre todo experimentar (de ahí el término jam, que hace consonancia a las Jam Sessions, que son eventos musicales para improvisar, sobre todo en el jazz). En esta ocasión me presenté a la Indie Spain Jam, que es una game jam anual (esta es su segunda entrega) hecha dentro de la organización de la IndieDevDay, la feria de videojuegos más importante a nivel español. A pesar de que cualquiera puede montar su stand y ofrecer un punto de promoción para algún proyecto, esta feria hace hincapié en, como su nombre indica, los videojuegos indie. Es por eso que el año pasado, pensando en potenciar este espacio de promoción de &quot;lo indie&quot;, organizaron su propia Game Jam.</p>
        <p>Una de las cosas que distingue un evento de jam es que hay un tema central sobre el que gira el desarrollo. No es obligatorio, porque existen jams en las que el tema es libre, o que está fijado por el evento del que trata (si es una jam de juegos de gameboy, la idea es que tenga las limitaciones cercanas a las de un juego de gameboy, como puede ser la paleta de colores o el número de sonidos que se pueden reproducir juntos). Este año el tema de la Indie Spain Jam era &quot;cae la noche&quot;, y a ver, te lo puedes tomar de forma literal o puedes empezar a armar una historia en donde la noche es la protagonista, al final el límite es contar con un scope que puedas realizar bien en una semana (a veces incluso menos, pero ya hablaré de eso).</p>
        <p>Y yo me lo tomé literal. No es que caiga la noche, pero si parte de ella. Mi idea era hacer que la luna cayese contra la tierra, y, a ver, puede parecer un concepto sencillo: le pones físicas a la luna para que caiga a la tierra y listo... pero se me escapaba que tenía que enfrentarme a un problema. Mi idea era imitar un poco un Angry Birds, con la principal mecánica de hacer que pudieras impulsar la luna y está trazara una parábola como estudiamos en física del colegio. Pero claro, aquí no somos terraplanistas como la gente de Angry Birds. Mi tierra es redonda (es un juego 2D, se me olvidó comentarlo), por lo que aquí encontré el problema.</p>
        <p>Normalmente en los videojuegos, cuando aplicamos físicas suponemos que existe una fuerza de la gravedad que tira los objetos hacia abajo de la pantalla. Esta gravedad no tiene que coincidir con la gravedad terrestre, ya que, salvo que tu juego tenga un tema realista, este valor normalmente se ajusta con la idea de que en pantalla se muestre algo que sea divertido, jugable o incluso directamente se scripta (por ejemplo cuando tenemos plataformas de salto que tienen que llevar a una zona concreta del nivel). Aquí podríamos incluso jugar con el propósito de game feel y añadir impulsos, momentos y demás para hacer que el juego se sienta natural a pesar de no tener una gravedad como en la tierra. Como resumen, una de las cosas más recurrentes en la literatura del diseño de videojuegos es realizar trampitas, pero que no se noten.</p>
        <p>Pues con esta idea decidí mirar a ver como modificar las físicas de Godot para mostrar algo que me convenciera, o al menos hacer algo que resolviera el problema. Revisando cómo funciona el sistema de físicas, Godot tiene dos funciones principales que me podían servir para esto. La primera es <code>_physics_process()</code>, que es muy similar a la función <code>FixedUpdate()</code> de Unity. Este callback se llama en el mismo frame donde se actualiza el motor de físicas, porque a diferencia de lo que se puede pensar, normalmente los motores de videojuegos actualizan las físicas a una duración constante. Esto se realiza para que las colisiones se detecten siempre de forma determinista. En Godot viene configurado para que sea llamado a 0.016 segundos (60 veces por segundo). La cosa es que esta función, aunque está sincronizada con la actualización de físicas, no permite una actualización correcta del estado físico del objeto porque, al menos en Godot, el sistema de físicas se ejecuta paralelamente en otro proceso independiente. Para estas cosas, si tu nodo deriva de un RigidBody, existe la función <code>_integrate_forces()</code>, que nos permite modificar de forma segura el estado físico del nodo, aplicarle fuerzas, etc. Incluso con esta función podríamos hacer nuestras físicas custom en vez de usar la del motor de físicas si también ponemos a true el atributo de custom_integrator. En mi caso me interesa cambiar cómo funciona solo la gravedad, por lo que no voy a desactivarlo completamente.</p>
        <p>Teniendo esto en cuenta la idea es establecer una fuerza radial que siempre apunte al centro del planeta. Podríamos usar la función de la gravedad para dos cuerpos para que el valor de esta fuerza tenga en cuenta la distancia y demás, pero como ya dije antes, estamos aquí para hacer trampitas, y que el jugador mande la luna a velocidad de escape de la tierra no es que sea divertido, por lo que no lo voy a tener en cuenta. Para que afecte un poco eso de que que a mayor distancia atrae menos, si que le aplico esto, pero hasta una distancia máxima, a partir de ahí siempre va a atraer a la tierra. Con todo esto, mi función quedó con el código siguiente:</p>
        <pre><code class="language-gdscript">27  func _integrate_forces(state):
        28      var direction = earth.global_position - global_position
        29      var force = min(max(direction.length(), 2048.0), 8192.0)
        30      gravity = direction.normalized() * Constants.GRAVITY * force / 2048.0
        31      state.apply_central_force(gravity)
        </code></pre>
        <p>Luego, para que siempre se aplique esta función, puse que el objeto tenga siempre gravedad 0, que es un parámetro que se puede ajustar en el RigidBody. Además, lo bueno de poder saber cómo interactúa la gravedad en el objeto es que se puede también diseñar un sistema de predicción de donde va a acabar la luna, pero no lo voy a explicar en esta entrada porque está quedando bastante larga. Si queréis revisar más cosas de como hice este proyecto, tenéis todo el código disponible en mi <a href="https://gitlab.com/NEKERAFA/indie-spain-jam-23"><i class="fa-brands fa-gitlab"></i> GitLab</a>.</p>
        ]]>
      </content:encoded>
      <pubDate>Sat, 14 Oct 2023 19:49:16 GMT</pubDate>
      <atom:updated>2023-12-09T08:35:51.000Z</atom:updated>
    </item>
    <item>
      <title>La importancia de la tecnología</title>
      <link>https://blog.nekerafa.dev/posts/la-importancia-de-la-tecnologia/</link>
      <guid isPermaLink="false">https://blog.nekerafa.dev/posts/la-importancia-de-la-tecnologia/</guid>
      <description>Llevo unos meses pensando qué publicar en mi blog para retomarlo de nuevo, ya que la última entrada es de hace más de un año. Al final, he decidido hablar sobre uno de los problemas que más pasa en este mundillo. No es la primera vez que nos encontramos con varios problemas a veces difíciles de resolver al estar ligados a la tecnología que hemos elegido.</description>
      <content:encoded>
        <![CDATA[<p>Llevo unos meses pensando qué publicar en mi blog para retomarlo de nuevo, ya que la última entrada es de hace más de un año. Una posible entrada que tenía en mente es que empecé a desarrollar el año pasado un juego para Twitch basado en Cartas contra la Humanidad <a rel="noopener" href="https://github.com/NEKERAFA/Twitch-CAH" target="_blank"><i class="fa-brands fa-github"></i> github.com/NEKERAFA/Twitch-CAH</a>, que estaba programado en Lua, pero lo dejé parado porque me di cuenta que no iba a ser sencillo distribuirlo. Otra posible entrada que me surgió es que este año participé en la <a rel="noopener" href="https://itch.io/jam/numerica-twitch-jam" target="_blank"><i class="fa-brands fa-itch-io"></i> Numerica Twitch Jam</a> de <a rel="noopener" href="https://twitter.com/RothioTome" target="_blank">Rocío Tomé</a> con Pokédexica, un Numerica basado en completar la Pokédex nacional <a rel="noopener" href="https://github.com/NEKERAFA/pokedexica-twitch" target="_blank"><i class="fa-brands fa-github"></i> github.com/NEKERAFA/pokedexica-twitch</a>, y que quería hacer un resumen de fallos y cosas que aprendí (a lo resumen post-mortem), centrando sobre todo los problemas encontrados cuando la gente empezó a usar el juego.</p>
        <p>Y es que, al final, he decidido hablar sobre uno de los problemas que más pasa en este mundillo. No es la primera vez que a muches de nosotres nos ha pasado que, ya sea por no salir de nuestra zona de confort, por las limitaciones técnicas del marco de desarrollo que usamos o por no tener el suficiente conocimiento, nos encontramos con varios problemas a veces difíciles de resolver al estar ligados a la tecnología que hemos elegido.</p>
        <p>Una de las cosas que he escuchado de gente que se cree gurus de la informática es la frase de: “En este proyecto no vamos a estar ligados a la tecnología, vamos a desarrollar en lo que nos sintamos más cómodes”. Y podría parecer una buena idea al principio, porque muchas veces el objeto de los proyectos empresariales es el poder sacar un proyecto adelante en algo que no te suponga mucho esfuerzo. Tanto por un mejor mantenimiento y por contar con personal suficiente para llevarlo a delante. Pero sé de buena mano (ya sea de oídas o porque he tenido que comerme uno de esos proyecto) que al final no tener un estudio inicial de cual es la mejor forma de llevar a cabo ese proyecto arrastra fallos y problemas difíciles de resolver.</p>
        <p>A veces esto es imposible porque no se pueden prever todos los cambios y funcionalidades que se van a añadir en el proyecto, pero otras veces si que se saben ciertas restricciones y hasta que no se llega a las distintas funcionalidades problemáticas se arrastra esta deuda técnica hasta que es tarde.</p>
        <p>Pero otras veces si se puede prevenir, o al menos paliar, pero, por pura tozudez, no se piensa porqué se ha tomado esa decisión hasta que te estalla en la cara. Y esto es un tema común de los proyectos que os mencioné antes. Se podría resolver fácilmente los problemas principales que me encontré si hubiera dedicado un tiempo a planificarlo bien, pero no, pasó y aquí no hay nada que ver.</p>
        <p>Lo bueno es que de estos casos se aprende, y al final lo importante es dejar ese ego a un lado y analizar, aunque sean 5 minutos antes de lanzarse a programar, que es lo que se plantea hacer y cual es la mejor tecnología a aplicar en ese momento, aunque implique aprender algo nuevo. Porque de eso se trata, al final tener un buen conocimiento para saber que cosas aplicar en que momento preciso.</p>
        <p>En fin, no voy a alargar más esta entrada. En los próximos días añadiré las entradas a cada uno de los proyectos que mencioné anteriormente, así que estaros atentos y si queréis, suscribiros a <a href="https://blog.nekerafa.dev/feed.xml">mi RSS</a>. ¡Saludos 😸!</p>
        ]]>
      </content:encoded>
      <pubDate>Sun, 17 Sep 2023 18:36:00 GMT</pubDate>
      <atom:updated>2023-12-09T10:42:15.000Z</atom:updated>
    </item>
    <item>
      <title>Unha nova instancia en mastodon</title>
      <link>https://blog.nekerafa.dev/posts/unha-nova-instancia/</link>
      <guid isPermaLink="false">https://blog.nekerafa.dev/posts/unha-nova-instancia/</guid>
      <description>Esta vai ser unha entrada bastante cortiña. Veño anunciaros que, co motivo das letras galegas, acabo de engadir meu propio gran de area creando unha nova instancia para mastodon: mastodon.gal</description>
      <content:encoded>
        <![CDATA[<p>Boas a todes!!</p>
        <p>Esta vai ser unha entrada bastante cortiña. Veño anunciaros que, co motivo das letras galegas, acabo de engadir meu propio gran de area creando unha nova instancia para mastodon: <a rel="noopener" href="https://mastodon.gal/" target="_blank">mastodon.gal</a>.</p>
        <p>As inscripcións están abertas a todo o público (procurarei que ser bastante firme coas contas que se creen estos días).</p>
        <p>Os espero ver a todes alí, ata máis ver!!</p>
        ]]>
      </content:encoded>
      <pubDate>Tue, 17 May 2022 01:06:56 GMT</pubDate>
      <atom:updated>2023-12-09T10:42:15.000Z</atom:updated>
    </item>
    <item>
      <title>¡Hola mundo!</title>
      <link>https://blog.nekerafa.dev/posts/hola-mundo/</link>
      <guid isPermaLink="false">https://blog.nekerafa.dev/posts/hola-mundo/</guid>
      <description>Como veis, me he creado una web personal. En este espacio pondré cosillas que me irán surgiendo a lo largo de la vida (bueno, creo que todos entendemos el concepto de blog a estas alturas).</description>
      <content:encoded>
        <![CDATA[<p>¡Buenas a todes! 😼</p>
        <p>Como veis, me he creado una web personal. En este espacio pondré cosillas que me irán surgiendo a lo largo de la vida (bueno, creo que todos entendemos el concepto de blog a estas alturas).</p>
        <p>Además, también usaré esta web para subir tutoriales míos, como devlog de mis proyectos personales, y hasta recetas de comida (por qué no, que me encanta cocinar).</p>
        <p>Saludos y nos vemos pronto.</p>
        ]]>
      </content:encoded>
      <pubDate>Sat, 02 Apr 2022 12:21:18 GMT</pubDate>
    </item>
  </channel>
</rss>