---
title: Lo que necesitas saber antes de usar Godot
date: 2024-01-30T21:52:22.000Z
modified_date: 2024-02-10T12:53:20.000Z
tags:
  - tutorial
  - castellano
description: 'En esta entrada quer√≠a hablar de dos puntos clave a la hora de desarrollar en Godot, uno de los principales motores de c√≥digo abierto: la programaci√≥n orientaci√≥n a objetos por clases, y la programaci√≥n dirigida por eventos.'
---

Buenas gente, para 2024 me he propuesto subir al menos una entrada cada mes en mi blog, ya sea un tutorial o alguna opini√≥n m√≠a, a ver que os parece. Quer√≠a haber subido esta entrada antes, pero estuve de mudanza de proveedor de dominio, ya que Google Domains cerraba (si, hije, si, otro servicio m√°s), y quer√≠a mirar alg√∫n otro proveedor m√°s barato.

En esta entrada hablar√© de dos puntos clave a la hora de desarrollar en <a href="https://godotengine.org" target="_blank" rel="noopener">Godot</a>, uno de los principales motores de c√≥digo abierto en estos momentos, que cuenta con una base de desarrolladores y contribuidores cada vez m√°s grande, adem√°s de una comunidad bastante activa que nada tiene que envidiar a otros motores privativos como Unity o Unreal. Es por eso que creo que, ya seas principiante o, por el contrario, tengas un cierto conocimiento y experiencia previa, es fundamental que conozcas dos conceptos principalmente: La programaci√≥n orientada a objetos por clases y la programaci√≥n dirigida por eventos. Es verdad que otros motores tienen estos conceptos, y tampoco es algo nuevo que haya inventado Godot, pero, lo que me parece especial en este caso es que son caracter√≠sticas que vienen intr√≠nsecas en la arquitectura del propio motor.

Con respecto a la programaci√≥n orientada a objetos, no es un concepto sencillo a priori. En clases de programaci√≥n te cuentan que un objeto se divide en un estado, que es lo que se almacena en memoria, y una serie de eventos o mensajes a los que podemos llamar para modificar su estado. Esta divisi√≥n existe porque el punto principal de la programaci√≥n orientada a objeto es poder reutilizar el comportamiento de los elementos dentro del programa (por ejemplo c√≥mo responder al hacer click en un bot√≥n, c√≥mo reproducir una animaci√≥n, la forma para detectar colisiones, ‚Ä¶) de cosas que son concretas al elemento en si (el sprite que contiene la animaci√≥n, el tama√±o de la caja de colisiones o los colores de fondo del bot√≥n). Esta divisi√≥n es muy clara en los lenguajes de programaci√≥n orientada a objetos por clases, como es el caso de GDScript, y es que la clase act√∫a como el contrato y especificaci√≥n de los mensajes a los que podemos llamar (los m√©todos que hemos definido en la clase), y las instancias son punteros a espacios en la memoria del ordenador en donde se especifica el estado actual de un objeto dado (la forma del estado viene definido por los atributos y propiedades de la clase). Que conste que en los lenguajes de programaci√≥n orientados a prototipos como pueden ser Lua o ECMAscript tambi√©n existe esta diferencia, pero es m√°s borrosa, pero no entrar√© en detalle en este momento porque quiero hablar del caso particular de Lua en otro momento.

<p class="responsive-content"><a href="definicion_objeto.webp"><img src="definicion_objeto.webp" alt="Relaci√≥n de los elementos de un objeto"></a></p>
<p class="content-footer">Relaci√≥n de los elementos de un objeto.</p>

Entonces, por una parte definici√≥n de las clases y por otra las instancias, pero necesitamos poder relacionar estos conceptos para, en el caso que nos ata√±e, compartir informaci√≥n y relacionarla de alguna forma para poder construir un videojuego. Con respecto a relacionar la informaci√≥n tenemos una herramienta que nos da la propia programaci√≥n orientada a objetos por clases, que es la herencia. Y es que dada una clase, podemos hacer que esta incluya el comportamiento de una clase superior (lo que llamamos clase padre o superclase), y a su vez, crear nuevas clases que deriven de esta (las clases hijas o subclases). Con esto, podemos definir un comportamiento compartido entre clases en una superclase sin tener que reimplementarlo (o hacer un copy-paste) de cada vez. Ahora, con respecto a compartir la informaci√≥n hay una herramienta que nos permite simplificar de cierta forma la herencia, y es lo que se llama composici√≥n. Aqu√≠ lo que hacemos es que la clase tenga referencias directas a instancias de otras clases, y cuando tenemos que hacer algo, delegamos en los distintos m√©todos de las instancias a las que referenciamos. Y ahora podr√≠amos pensar: ¬øCu√°ndo usar uno u otro? De aqu√≠ hay mucha literatura de c√≥mo hacerlo, pero, poniendo el caso de Godot, pues la respuesta es que ambos sistemas. El motor usa una aproximaci√≥n mixta en la que el comportamiento de los objetos recaen en los Nodos, que son instancias de la clase <a href="https://docs.godotengine.org/en/stable/classes/class_node.html" target="_blank" rel="noopener">Node</a> o de una de sus subclases: tenemos desde <a href="https://docs.godotengine.org/en/stable/classes/class_node2d.html" target="_blank" rel="noopener">Node2D</a>, <a href="https://docs.godotengine.org/en/stable/classes/class_label.html" target="_blank" rel="noopener">Label</a>, <a href="https://docs.godotengine.org/en/stable/classes/class_animationplayer.html" target="_blank" rel="noopener">AnimationPlayers</a>, ¬°y hasta <a href="https://docs.godotengine.org/en/stable/classes/class_timer.html" target="_blank" rel="noopener">Timers</a>! En Godot, si necesitamos un elemento que haga las mismas funciones que un bot√≥n, podemos heredar de la clase <a href="https://docs.godotengine.org/en/stable/classes/class_button.html" target="_blank" rel="noopener">Button</a> (o incluso de <a href="https://docs.godotengine.org/en/stable/classes/class_basebutton.html" target="_blank" rel="noopener">BaseButton</a>, que es una clase abstracta pensada ya para eso). Pero claro, ahora necesitamos hacer que nuestros nodos se puedan comunicar entre ellos, por lo que aqu√≠ entra en juego la composici√≥n. Un ejemplo son las escenas, en la que un nodo puede tener hijos siguiendo una estructura de √°rbol. No se hereda, si no que a√±adimos referencias dentro de una lista de hijos, y en la que derivamos parte del comportamiento. Un ejemplo lo podemos ver en un personaje 2D: Empezar√≠amos con un <a href="https://docs.godotengine.org/en/stable/classes/class_characterbody2d.html" target="_blank" rel="noopener">CharacterBody2D</a> (si, Godot ya incorpora un player controller como nodo), y asignarle como hijos un <a href="https://docs.godotengine.org/en/stable/classes/class_collisionshape2d.html" target="_blank" rel="noopener">CollisionShape2D</a>, un <a href="https://docs.godotengine.org/en/stable/classes/class_sprite2d.html" target="_blank" rel="noopener">Sprite2D</a> (o incluso un <a href="https://docs.godotengine.org/en/stable/classes/class_animatedsprite2d.html" target="_blank" rel="noopener">AnimatedSprite2D</a> si queremos animaciones, sin necesidad del <a target="_blank" href="https://docs.godotengine.org/en/stable/classes/class_animationplayer.html" rel="noopener">AnimationPlayer</a>), y listo. Ahora viene la parte m√°s importante con respecto a esta forma de trabajar, y es que si queremos modificar el CharacterBody2D para meterle m√°s movimientos a nuestro personaje (por ejemplo correr o un movimiento de dash), solo tenemos que extender de este nodo en concreto (que lo podemos hacer a√±adi√©ndole un script al nodo desde el editor, que en esencia es una extensi√≥n de esta clase). Ten√©is m√°s informaci√≥n ten√©is este <a href="https://www.youtube.com/watch?v=74y6zWZfQKk" target="_blank" rel="noopener"><i class="fa-brands fa-youtube"></i> v√≠deo</a>.

<iframe class="responsive-content" width="100%" height="270px" src="https://www.youtube-nocookie.com/embed/74y6zWZfQKk?si=xmBKXU1T-G9vy8YO" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

Pues haciendo un breve resumen, en Godot tenemos composici√≥n de nodos en las escenas, y herencia dentro de un nodo al a√±adirle un script, y con esto estar√≠a todo‚Ä¶ bueno, todo no, y es que queda un detalle a mayores. La programaci√≥n orientada a objetos vino para arreglar muchos problemas de reutilizaci√≥n y divisi√≥n de c√≥digo, pero, como en sus inicios era un concepto bastante abstracto, sin unas reglas definidas, hizo que muchos desarrolladores empezaran a hacer c√≥digo insostenible (si, en vez de arreglar, empeor√≥ las cosas). Todo esto viene a que mucha gente ven√≠a con el chip de la programaci√≥n imperativa, donde cada instrucci√≥n se ejecuta l√≠nea a l√≠nea. Es verdad que muchos lenguajes imperativos incorporan formas de definir funciones, interfaces o incluso m√≥dulos, pero a√∫n as√≠ poco se parece al alto desacoplamiento que hay en un c√≥digo dividido en clases. Para ello, en 1994, un grupo de ingenieros de software, conocidos como ‚ÄúThe Gang of Four‚Äù, publicaron un libro que recopila unas reglas y formas de dise√±o que permitieran a los desarrolladores hacer de forma sencilla un mejor c√≥digo siguiendo sus recomendaciones. Este libro se llama ‚ÄúPatrones de dise√±o: elementos para un software object-oriented reusable‚Äù. Si, he dicho la frase secreta para entrar en un mundo oscuro de la programaci√≥n, que son los patrones de dise√±o. Un ente que tanto a estudiantes de inform√°tica como a seniors con 30 a√±os de experiencia en el sector se nos atraganta bastante.

<p class="responsive-content"><a href="herencia-vs-composicion.webp"><img width="100%" src="herencia-vs-composicion.webp" alt="Herencia vs. Composici√≥n"></a></p>
<p class="content-footer">Herencia vs. Composici√≥n.</p>

No entrar√© en detalles, porque este no es un tutorial sobre patrones de dise√±o (si quer√©is ejemplos, ten√©is el libro de <a href="https://gameprogrammingpatterns.com/" target="_blank" rel="noopener">Game Programming Patterns</a>, de Robert Nystrom), pero dos de los patrones que tenemos que tener claro en Godot es el patr√≥n <a href="https://gameprogrammingpatterns.com/observer.html" target="_blank" rel="noopener">Observador</a> y el patr√≥n <a href="https://refactoring.guru/design-patterns/chain-of-responsibility" target="_blank" rel="noopener">Cadena de responsabilidad</a>.El primer patr√≥n se define con dos componentes: un sujeto o objeto observable (que contiene una lista de objetos a los que notificar de posibles cambios o eventos) y un observador (que puede recibir estas notificaciones o eventos). En el caso del segundo patr√≥n tenemos lo contrario, un objeto que tiene que realizar un trabajo (emisor), y delega en otro componente llamado receptor o manejador, que a su vez puede delegar en un segundo componente hasta llegar a un componente que nos permite realizar el trabajo requerido. Teniendo esto claro podemos entrar en lo que se llama programaci√≥n orientada a eventos, caracterizada por mecanismos en los que procesos env√≠an y reciben eventos, los procesan y/o delegan en otros componentes para realizar acciones. Muchos lenguajes de programaci√≥n lo implementan mediante los llamados events, delegates y dem√°s, pero Godot tiene una soluci√≥n muy elegante para implementar esto: las se√±ales. Ten√©is un <a href="https://www.youtube.com/watch?v=BXkJeEGZr4o" target="_blank" rel="noopener"><i class="fa-brands fa-youtube"></i> v√≠deo</a> en el que lo explica de forma sencilla, as√≠ que voy a centrarme en lo importante, y es que la idea principal de las se√±ales es el poder desacoplar de forma sencilla el comportamiento de los nodos, delegando su trabajo en otros sin tener que conocerlos.

<iframe class="responsive-content" width="100%" height="270px" src="https://www.youtube-nocookie.com/embed/BXkJeEGZr4o?si=XUd7irztklN9N0_K" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

Para explicarlo sigamos con el ejemplo de la escena de personaje. Supongamos que queremos detectar cuando el personaje colision√≥ con un obst√°culo que puede hacerle da√±o. Podemos empezar a definir dos se√±ales en el Player: `damaged` que se usar√° para notificar al Player de que ha sufrido da√±os, y `life_changed`, que recibe por par√°metro la vida actual para notificar a los nodos que lo necesiten de que la vida del jugador ha cambiado. Para centralizar la informaci√≥n en el objeto, el Player contendr√° su vida actual. Con esto podemos conectar la se√±al de `damaged` a una funci√≥n que tiene el Player que sea `on_damaged`, y en la que podemos hacer que se reste una vida y emita la se√±al de `life_changed`. Bien, ¬øy c√≥mo comprobamos que el jugador ha sufrido da√±os? Pues haciendo que sea el otro objecto. Si, por ejemplo, este hereda de un <a target="_blank" href="https://docs.godotengine.org/en/stable/classes/class_area2d.html" rel="noopener">Area2D</a> tenemos la se√±al de `body_entered`, que podemos conectar a una funci√≥n que sea `on_body_entered` dentro del obst√°culo. Comprobando que si el objeto que colisiona tiene el nombre de "Player", podemos emitir su se√±al de `damaged`. Bien, ahora necesitamos que tanto nuestro HUD como nuestro GameManager reaccione al cambio de vida (ya sea para modificar el n√∫mero de vidas en pantalla o comprobar si el jugador ha muerto para ir a la pantalla de fin de juego). En este paso podr√≠amos referenciar a estos objetos con el jugador para leer su vida en todo momento, pero es que para eso tenemos la se√±al creada antes. Si conectamos a cada objeto a esta se√±al, podemos hacer eso sin tener que acoplarlos al objeto del jugador. Con todo esto podemos poner la pega de que tenemos un c√≥digo con un flujo con m√°s carga al estar saltando de un objeto al otro, ya que las se√±ales no son gratis y generar un overhead al invocar todo, pero, dependiendo de c√≥mo implementamos el c√≥digo, podemos obtener una buena mejoras y es que en Godot podemos responder a todos los objetos de forma paralela. Adem√°s, con esto tenemos un c√≥digo m√°s desacoplado, en el que cada clase tiene definida su funcionalidad, y por ende, m√°s mantenible. Por ejemplo, podemos a√±adir m√°s objetos que hagan da√±o al jugador replicando el funcionamiento de la bala.

```gdscript
## player.gd
extends CharacterBody2D

signal damaged
signal life_changed(lifes)

var lifes = 0

func on_damaged(): # conectado con damaged
    lifes -= 1
    life_changed.emit(lifes)

...
```

```gdscript
## bullet.gd
extends Area2D

func on_body_entered(body): # conectado con body_entered
    if body.name == "Player":
        body.damaged.emit()

...
```

<p class="content-footer">Ejemplo de implementaci√≥n de los scripts.</p>

Hay muchas cosas m√°s de las que podr√≠a hablar en Godot, porque pese a su peque√±o tama√±o, en realidad es un motor con bastantes cosas y de la que no es f√°cil masterizar y aprenderlo en una sola entrada, pero pienso que para empezar los dos temas que he tratado (escenas y nodos, y se√±ales) son la base que tenemos que tener claro desde la primera toma de contacto para poder dominar Godot. Con todo, el mejor consejo que os puedo decir es que revisad la documentaci√≥n, que a cada d√≠a que pasa est√° mucho m√°s completa, y sobre todo haced cosas y experimentad con el motor, porque con ensayo y error es como m√°s se aprende. Dicho esto espero que os haya gustado este tipo de entradas, que tengo ya algunas ideas en mente.

¬°Nos vemos en la pr√≥xima, saludos üòΩ!
